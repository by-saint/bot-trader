<!DOCTYPE html>
<html lang="pt-PT">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MB Sniper | QUANTUM-VORTEX Omni-Asset — V-Reversal Detector</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Plus+Jakarta+Sans:wght@300;400;600;800&display=swap');
    :root { --accent: #4f46e5; --bg: #010103; }
    body { font-family: 'Plus Jakarta Sans', sans-serif; background-color: var(--bg); color: #f8fafc; overflow-x: hidden; }
    .mono { font-family: 'JetBrains Mono', monospace; }
    .glass { background: rgba(5,5,12,0.95); backdrop-filter: blur(36px); border: 1px solid rgba(255,255,255,0.04); }
    .progress-bar { height: 3px; background: linear-gradient(90deg,#4f46e5,#c084fc); box-shadow: 0 0 15px #4f46e5; transition:width .2s ease; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
  const { useState, useEffect, useCallback, useRef } = React;

  /***************************************************************
   * PARAMETROS FÁCEIS DE AJUSTE — mexa aqui para calibrar sensibilidade
   ***************************************************************/
  const OMNI_WHITELIST = ['BTC','ETH','SOL','XRP','ADA','DOT','LINK','AVAX','MATIC','LTC','BCH','DOGE','NEAR','ALGO','ATOM','UNI','AAVE','MANA','GRT','OP','ARB','SUI','APT'];

  const ENGINE = {
    FEE_MB: 0.014,
    SPREAD_BUFFER: 0.005,
    COOLDOWN_MS: 60_000,
    POOL_CONCURRENCY: 4,
    MIN_QUOTE_VOL: 1_500_000,

    // Reversal detection
    DROP_WINDOW_CANDLES: 12,      // quantos candles atrás para medir queda (em 15m => 3h)
    MIN_DROP_PCT: 7.0,            // queda mínima em % para ser considerada candidata
    VOLUME_SPIKE_MULT: 1.6,       // multiplicador de volume que considera "spike"
    RSI_RECOVERY_DELTA: 6,        // subida mínima de RSI em pontos para confirmar recuperação
    EMA_FAST: 8,
    EMA_SLOW: 21,
    ATR_BODY_MULT: 1.0,           // corpo de vela > ATR * este multiplicador indica força
    MIN_NET_PROFIT_PCT: 1.0       // lucro líquido mínimo para exibir sinal
  };

  /***************************************************************
   * UTILS NUMÉRICOS (defensivos)
   ***************************************************************/
  const safe = v => {
    const n = parseFloat(v);
    return Number.isFinite(n) ? n : 0;
  };
  const mean = arr => arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0;
  const stddev = arr => {
    if (!arr.length) return 0;
    const m = mean(arr);
    return Math.sqrt(arr.reduce((s,x)=>s + Math.pow(x-m,2),0)/arr.length);
  };

  // ATR correto (usa índices absolutos)
  function atrFromKlines(klines, window = 14) {
    if (!Array.isArray(klines) || klines.length < 2) return 0;
    const start = Math.max(1, klines.length - window);
    const trs = [];
    for (let i = start; i < klines.length; i++) {
      const high = safe(klines[i][2]);
      const low  = safe(klines[i][3]);
      const prevC = safe(klines[i-1][4]);
      trs.push(Math.max(high - low, Math.abs(high - prevC), Math.abs(low - prevC)));
    }
    return trs.length ? trs.reduce((a,b)=>a+b,0)/trs.length : 0;
  }

  // EMA simples (requere array de closes)
  function emaArray(closes, window) {
    if (!closes.length) return null;
    const w = Math.min(window, closes.length);
    const k = 2 / (w + 1);
    let ema = mean(closes.slice(0, w));
    for (let i = w; i < closes.length; i++) {
      ema = closes[i] * k + ema * (1 - k);
    }
    return ema;
  }

  // RSI básico
  function computeRsi(closes, period = 14) {
    if (closes.length < period + 1) return 50;
    const changes = [];
    for (let i = closes.length - period - 1; i < closes.length - 1; i++) {
      changes.push(closes[i+1] - closes[i]);
    }
    const gains = changes.map(x => x > 0 ? x : 0);
    const losses = changes.map(x => x < 0 ? Math.abs(x) : 0);
    const avgG = mean(gains);
    const avgL = mean(losses) || 1;
    const rs = avgG / avgL;
    return 100 - (100 / (1 + rs));
  }

  /***************************************************************
   * DETECÇÃO DE V-REVERSAL (nova função)
   * Algoritmo (passo a passo):
   * 1) Detecta queda % em janela (DROP_WINDOW_CANDLES)
   * 2) Verifica vela de recuperação recente: corpo verde grande (> ATR*ATR_BODY_MULT)
   * 3) Volume spike na vela verde (volume > avgVol * VOLUME_SPIKE_MULT)
   * 4) EMA fast cruza acima EMA slow (momentum curto)
   * 5) RSI estava em sobrevenda e está subindo (delta >= RSI_RECOVERY_DELTA)
   * 6) Checagem de profundidade/orderbook para evitar thin markets
   ***************************************************************/
  async function detectVReversal(symbol, k5, k15, k1h, ticker24, usdtBrl) {
    try {
      // validação
      if (!k15 || k15.length < ENGINE.DROP_WINDOW_CANDLES + 3) return null;

      const closes = k15.map(k => safe(k[4]));
      const volumes = k15.map(k => safe(k[5]));
      const len = closes.length;
      const current = closes[len - 1];
      const earlierIdx = Math.max(0, len - ENGINE.DROP_WINDOW_CANDLES - 1);
      const earlierPrice = closes[earlierIdx];

      // 1) queda percentual
      const dropPct = ((earlierPrice - current) / earlierPrice) * 100;
      if (!(dropPct >= ENGINE.MIN_DROP_PCT)) return null; // não caiu o suficiente

      // 2) vela de recuperação (última vela)
      const lastK = k15[k15.length - 1];
      const lastOpen = safe(lastK[1]);
      const lastClose = safe(lastK[4]);
      const lastHigh = safe(lastK[2]);
      const lastLow = safe(lastK[3]);
      const lastVol = safe(lastK[5]);
      const body = Math.abs(lastClose - lastOpen);
      const bodyIsBull = lastClose > lastOpen;

      const atr = atrFromKlines(k15, 14);
      if (!bodyIsBull) return null; // precisamos de vela de alta no gatilho
      if (!(body > atr * ENGINE.ATR_BODY_MULT)) return null; // vela forte

      // 3) volume spike
      const avgVol = mean(volumes.slice(-20));
      if (!(lastVol > avgVol * ENGINE.VOLUME_SPIKE_MULT)) return null;

      // 4) EMA cross (usar closes de 5m ou 15m)
      const closesForEma = closes.slice(-Math.max(ENGINE.EMA_SLOW * 3, 60));
      const emaFast = emaArray(closesForEma, ENGINE.EMA_FAST);
      const emaSlow = emaArray(closesForEma, ENGINE.EMA_SLOW);
      if (!emaFast || !emaSlow) return null;
      if (!(emaFast > emaSlow)) return null; // confirma momento de subida

      // 5) RSI recovery
      const rsiNow = computeRsi(closes, 14);
      // RSI some candles back
      const rsiBefore = computeRsi(closes.slice(0, Math.max(0, closes.length - 3)), 14);
      const rsiDelta = rsiNow - rsiBefore;
      if (!(rsiDelta >= ENGINE.RSI_RECOVERY_DELTA)) return null;

      // 6) quick liquidity check (orderbook depth)
      const depthOk = await (async () => {
        try {
          const res = await fetch(`https://api.binance.com/api/v3/depth?symbol=${symbol}&limit=50`);
          if (!res.ok) return false;
          const d = await res.json();
          const bids = Array.isArray(d.bids) ? d.bids.slice(0, 8) : [];
          const asks = Array.isArray(d.asks) ? d.asks.slice(0, 8) : [];
          const bidNot = bids.reduce((s,b)=>s + safe(b[0]) * safe(b[1]), 0);
          const askNot = asks.reduce((s,a)=>s + safe(a[0]) * safe(a[1]), 0);
          const notional = Math.min(bidNot, askNot);
          return notional >= 5_000; // em USDT notional mínimo (ajustável)
        } catch(e) { return false; }
      })();

      if (!depthOk) return null;

      // se chegou até aqui é candidato forte
      // métricas de interesse
      const estimatedTarget = current + atr * 2.8;
      const netProfitPct = ((estimatedTarget / current) - 1 - ENGINE.FEE_MB - ENGINE.SPREAD_BUFFER) * 100;
      if (netProfitPct < ENGINE.MIN_NET_PROFIT_PCT) return null;

      return {
        coin: symbol.replace('USDT',''),
        symbol,
        current,
        dropPct: dropPct.toFixed(2),
        atr,
        body,
        lastVol,
        avgVol,
        rsiNow: rsiNow.toFixed(2),
        rsiDelta: rsiDelta.toFixed(2),
        emaFast: emaFast.toFixed(6),
        emaSlow: emaSlow.toFixed(6),
        target: estimatedTarget,
        stop: Math.max( current - atr * 1.6, current * 0.985 ), // stop mais conservador
        netProfitPct: netProfitPct.toFixed(2),
        reason: `Drop ${dropPct.toFixed(2)}% + strong green candle + vol spike + EMA cross + RSI recovery`
      };

    } catch (err) {
      console.warn('detectVReversal error', err);
      return null;
    }
  }

  /***************************************************************
   * ENGINE PRINCIPAL (integra detecção de V-reversals)
   ***************************************************************/
  const App = () => {
    const [signals, setSignals] = useState([]);
    const [status, setStatus] = useState('INICIANDO');
    const [usdtBrl, setUsdtBrl] = useState(0);
    const [loading, setLoading] = useState(true);
    const [progress, setProgress] = useState(0);
    const isRunning = useRef(false);

    const fmtBRL = v => {
      try {
        return v.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL', minimumFractionDigits: v < 1 ? 4 : 2 });
      } catch { return 'R$ ' + Number(v).toFixed(2); }
    };

    const safeFetchJson = async (url) => {
      try {
        const r = await fetch(url);
        if (!r.ok) return null;
        return await r.json();
      } catch (e) { return null; }
    };

    const run = useCallback(async () => {
      if (isRunning.current) return;
      isRunning.current = true;
      setLoading(true);
      setProgress(5);
      setStatus('BUSCANDO TAXAS E CANDLES');

      // 1) USDTBRL
      let rate = 5;
      try {
        const p = await safeFetchJson('https://api.binance.com/api/v3/ticker/price?symbol=USDTBRL');
        if (p && p.price) rate = safe(p.price);
      } catch(e){}

      setUsdtBrl(rate);
      setProgress(12);

      // 2) tickers 24h
      const tickers = await safeFetchJson('https://api.binance.com/api/v3/ticker/24hr') || [];
      const candidates = tickers.filter(t => {
        const base = t.symbol.replace('USDT','');
        return OMNI_WHITELIST.includes(base) && safe(t.quoteVolume) > ENGINE.MIN_QUOTE_VOL;
      });

      const final = candidates.length ? candidates : tickers.filter(t => OMNI_WHITELIST.includes(t.symbol.replace('USDT',''))).slice(0,50);

      setProgress(18);

      const groups = [];
      for (let i=0; i<final.length; i += ENGINE.POOL_CONCURRENCY) groups.push(final.slice(i, i + ENGINE.POOL_CONCURRENCY));
      const found = [];

      for (let gi = 0; gi < groups.length; gi++) {
        setProgress(Math.round(18 + (gi / groups.length) * 70));
        const group = groups[gi];
        await Promise.all(group.map(async (tkr) => {
          const symbol = tkr.symbol;
          try {
            // obter candles 5m, 15m, 1h
            const [k5, k15, k1h] = await Promise.all([
              safeFetchJson(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=5m&limit=40`),
              safeFetchJson(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=15m&limit=120`),
              safeFetchJson(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=250`)
            ]);
            if (!k15) return;

            // 1) ver reversão tipo V
            const v = await detectVReversal(symbol, k5, k15, k1h, tkr, rate);
            if (v) {
              // enriquecer com BRL
              v.priceBRL = v.current * rate;
              v.targetBRL = v.target * rate;
              v.stopBRL = v.stop * rate;
              found.push(v);
              return;
            }

            // 2) se não V-reversal, pode usar heurística padrão (mantive simples)
            // Exemplo: score baseado em computePrecisionMetrics (mais permissivo)
            // (omito para foco em V-reversal)
          } catch (e) {
            console.warn('proc tick', symbol, e);
          }
        }));
        // pequeno pause para reduzir chance de rate-limit
        await new Promise(r => setTimeout(r, 120));
      }

      // ordenar por drop pct mais acentuado e netProfit
      found.sort((a,b) => (parseFloat(b.netProfitPct) - parseFloat(a.netProfitPct)) || (parseFloat(b.dropPct) - parseFloat(a.dropPct)));
      setSignals(found);
      setProgress(100);
      setLoading(false);
      setStatus(`IDLE - ${found.length} sinais detectados`);
      isRunning.current = false;
    }, []);

    useEffect(() => {
      run();
      const t = setInterval(() => run(), ENGINE.COOLDOWN_MS);
      return () => clearInterval(t);
    }, [run]);

    return (
      <div className="max-w-6xl mx-auto p-4 lg:p-8 min-h-screen">
        <div className="fixed top-0 left-0 right-0 h-1 bg-white/5 z-50"><div className="progress-bar" style={{width: `${progress}%`}}/></div>

        <header className="glass p-6 rounded-lg mb-8">
          <div className="flex justify-between items-center">
            <div>
              <h1 className="text-2xl font-bold">Quantum-Vortex — V-Reversal Scanner</h1>
              <p className="text-sm text-slate-300">{status} • USDT/BRL: {usdtBrl.toFixed(2)}</p>
            </div>
            <div className="flex gap-3">
              <button onClick={() => { setLoading(true); run(); }} className="px-4 py-2 bg-indigo-600 rounded text-white">Rodar Agora</button>
            </div>
          </div>
        </header>

        <main className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          <section className="lg:col-span-2 space-y-4">
            {loading ? (
              <div className="glass p-12 rounded">Executando scan...</div>
            ) : signals.length === 0 ? (
              <div className="glass p-12 rounded">Nenhuma V-reversal detectada agora.</div>
            ) : signals.map((s, i) => (
              <article key={i} className="glass p-6 rounded shadow">
                <div className="flex justify-between items-start">
                  <div>
                    <h2 className="text-xl font-bold">{s.coin} <span className="text-sm text-slate-300">({s.symbol})</span></h2>
                    <p className="text-sm text-slate-400">{s.reason}</p>
                  </div>
                  <div className="text-right">
                    <div className="text-lg font-black">{s.score ? s.score+'%' : ''}</div>
                    <div className="text-xs text-slate-400">Drop: {s.dropPct}%</div>
                  </div>
                </div>

                <div className="grid grid-cols-3 gap-3 mt-4">
                  <div className="p-3 bg-white/3 rounded">
                    <div className="text-xs text-slate-300">Preco (USDT)</div>
                    <div className="font-mono font-bold">{s.current.toFixed(6)}</div>
                    <div className="text-xs text-slate-400">{fmtBRL(s.priceBRL)}</div>
                  </div>
                  <div className="p-3 bg-white/3 rounded">
                    <div className="text-xs text-slate-300">Target</div>
                    <div className="font-mono font-bold">{s.target.toFixed(6)}</div>
                    <div className="text-xs text-slate-400">{fmtBRL(s.targetBRL)}</div>
                  </div>
                  <div className="p-3 bg-white/3 rounded">
                    <div className="text-xs text-slate-300">Stop</div>
                    <div className="font-mono font-bold">{s.stop.toFixed(6)}</div>
                    <div className="text-xs text-slate-400">{fmtBRL(s.stopBRL)}</div>
                  </div>
                </div>

                <div className="mt-3 flex gap-3 items-center">
                  <div className="text-xs text-slate-400">NetProfit Est.: <span className="font-bold">{s.netProfitPct}%</span></div>
                  <div className="text-xs text-slate-400">RSI Δ: {s.rsiDelta}</div>
                  <div className="ml-auto">
                    <a href={`https://www.mercadobitcoin.com.br/negociacoes/${s.coin.toLowerCase()}`} target="_blank" rel="noopener noreferrer" className="px-3 py-2 bg-white text-black rounded text-xs">Abrir no MB</a>
                    <button onClick={() => navigator.clipboard?.writeText(JSON.stringify(s))} className="ml-2 px-3 py-2 bg-white/5 rounded text-xs">Copiar</button>
                  </div>
                </div>
              </article>
            ))}
          </section>

          <aside className="space-y-4">
            <div className="glass p-4 rounded">
              <h3 className="font-bold">Parâmetros</h3>
              <ul className="text-sm text-slate-400 mt-2">
                <li>Janela de queda: {ENGINE.DROP_WINDOW_CANDLES} candles 15m</li>
                <li>Queda mín.: {ENGINE.MIN_DROP_PCT}%</li>
                <li>Multiplicador volume: {ENGINE.VOLUME_SPIKE_MULT}x</li>
                <li>EMA fast/slow: {ENGINE.EMA_FAST}/{ENGINE.EMA_SLOW}</li>
                <li>ATR body mult.: {ENGINE.ATR_BODY_MULT}x</li>
              </ul>
            </div>

            <div className="glass p-4 rounded">
              <h3 className="font-bold">Notas rápidas</h3>
              <ul className="text-sm text-slate-400 mt-2">
                <li>Este scanner foca em V-reversals: queda forte seguida de vela verde volumosa + momento.</li>
                <li>Teste em conta demo antes de operar — front-end only expõe limitações/risco.</li>
                <li>Se quiser, eu adiciono: trailing entry (pullback entry após vela de força), ou otimização automática de parâmetros por backtest.</li>
              </ul>
            </div>
          </aside>
        </main>
      </div>
    );
  };

  ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
