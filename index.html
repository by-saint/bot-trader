<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MB Sniper Quantum-Vortex | OMNIS VISION — Frontend Only</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Plus+Jakarta+Sans:wght@300;400;600;800&display=swap');
    :root { --accent: #6366f1; --bg: #020205; }
    body { font-family: 'Plus Jakarta Sans', sans-serif; background-color: var(--bg); color: #f8fafc; overflow-x: hidden; }
    .mono { font-family: 'JetBrains Mono', monospace; }
    .glass { background: rgba(10, 10, 15, 0.8); backdrop-filter: blur(18px); border: 1px solid rgba(255,255,255,0.03); }
    .glow-indigo { box-shadow: 0 0 60px -15px rgba(99,102,241,0.45); }
    .scan-bar { height: 2px; background: linear-gradient(90deg, transparent, #6366f1, transparent); width: 100%; position: absolute; z-index: 10; animation: scanning 2.8s linear infinite; }
    @keyframes scanning { 0% { top: 0; } 100% { top: 100%; } }
    .h-gradient { background: linear-gradient(135deg, #fff 20%, #6366f1 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
    .progress-bar { height: 4px; background: linear-gradient(90deg, #4f46e5, #818cf8); transition: width 0.4s cubic-bezier(0.4,0,0.2,1); box-shadow: 0 0 15px #6366f1; }
    .tech-card:hover { border-color: rgba(99,102,241,0.45); transform: translateY(-4px); transition: all 0.25s ease; }
    .btn { cursor: pointer; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    /**************************************************************************
     * CONFIGURAÇÕES — ajuste conforme necessidade
     *
     * NOTE: inserir qualquer chave API no front-end significa que ela será
     * publicamente visível. É fortemente recomendado usar backend para chaves.
     **************************************************************************/
    const config = {
      API_KEY_LLMS: "", // Opcional: chave para modelo generativo (ex.: Gemini). DE RISCO se exposto.
      // Lista alvo (expanda/ate conforme preferência)
      MB_WHITELIST: [
        'BTC','ETH','SOL','XRP','ADA','DOT','LINK','AVAX','MATIC','LTC',
        'BCH','DOGE','NEAR','ALGO','ATOM','UNI','AAVE','MANA','GRT','OP','ARB','SUI','APT'
      ],
      SCAN_INTERVAL: 60_000, // milissegundos
      POOL_CONCURRENCY: 4, // quantos tickers buscar em paralelo
      MIN_QUOTE_VOL: 1_500_000, // filtro de liquidez
      FEE_MB: 0.014,
      SAFETY_BUFFER: 0.005,
      MIN_CONFIDENCE: 75, // para considerar sinal final
      MAX_CAPITAL_PERCENT_PER_TRADE: 3, // % do capital por trade sugerido
      INITIAL_CAPITAL_BRL: 20000 // para sizing e backtest default
    };

    /**************************************************************************
     * UTILS - cálculos técnicos robustos
     **************************************************************************/
    const safeParseFloat = (v) => {
      const n = parseFloat(v);
      return isNaN(n) ? 0 : n;
    };

    function sma(arr, window) {
      const w = Math.min(window, arr.length);
      if (w === 0) return null;
      const slice = arr.slice(-w);
      return slice.reduce((a,b)=>a+ b, 0)/w;
    }

    function ema(arr, window) {
      if (!arr.length) return null;
      const w = Math.min(window, arr.length);
      const k = 2 / (w + 1);
      // start from sma of first window
      let emaPrev = arr.slice(0, w).reduce((a,b)=>a+b,0)/w;
      for (let i = w; i < arr.length; i++) {
        emaPrev = arr[i] * k + emaPrev * (1 - k);
      }
      return emaPrev;
    }

    function rsi(arr, window = 14) {
      if (arr.length < 2) return null;
      const changes = [];
      for (let i = 1; i < arr.length; i++) {
        changes.push(arr[i] - arr[i-1]);
      }
      const gains = changes.map(x => x > 0 ? x : 0);
      const losses = changes.map(x => x < 0 ? Math.abs(x) : 0);
      const avgGain = sma(gains, window) || 0;
      const avgLoss = sma(losses, window) || 0;
      if (avgLoss === 0) return 100;
      const rs = avgGain / avgLoss;
      return 100 - (100 / (1 + rs));
    }

    function bollinger(arr, window = 20, mult = 2) {
      if (arr.length < window) return null;
      const slice = arr.slice(-window);
      const mean = slice.reduce((a,b)=>a+b,0)/window;
      const variance = slice.reduce((a,b)=>a + Math.pow(b - mean,2), 0) / window;
      const sd = Math.sqrt(variance);
      return { upper: mean + mult * sd, lower: mean - mult * sd, mean, sd };
    }

    function atrFromKlines(k15, window = 14) {
      // k format: [openTime, open, high, low, close, volume, ...]
      if (!k15 || k15.length < 2) return 0;
      const tr = [];
      // calcular TR de forma absoluta e correta
      for (let i = Math.max(1, k15.length - window); i < k15.length; i++) {
        const high = safeParseFloat(k15[i][2]);
        const low = safeParseFloat(k15[i][3]);
        const prevClose = safeParseFloat(k15[i-1][4]);
        tr.push(Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose)));
      }
      return tr.length ? tr.reduce((a,b)=>a+b,0)/tr.length : 0;
    }

    /**************************************************************************
     * Helper: pool/parallel chunking para evitar rate limits
     **************************************************************************/
    function chunkArray(arr, size) {
      const out = [];
      for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
      return out;
    }

    /**************************************************************************
     * Local Omnis Heuristics (fallback) — combina vários indicadores para
     * gerar uma decisão e "confidence". Isto é o coração do robo sem IA remota.
     **************************************************************************/
    function localOmnisValidate(symbol, k15, k1h, context) {
      // Precondições
      if (!k15 || k15.length < 20 || !k1h || k1h.length < 50) {
        return { decision: "HOLD", confidence: 0, reason: "Insufficient data" };
      }
      const closes15 = k15.map(k => safeParseFloat(k[4]));
      const closes1h = k1h.map(k => safeParseFloat(k[4]));

      const current = closes15[closes15.length - 1];
      const sma200 = sma(closes1h, 200) || closes1h[closes1h.length - 1];
      const ema50 = ema(closes15, 50) || closes15[closes15.length - 1];
      const rsi14 = rsi(closes15, 14);
      const bb = bollinger(closes15, 20, 2);
      const atr = atrFromKlines(k15, 14);
      const volCurrent = safeParseFloat(k15[k15.length -1][5]);
      const volAvg = k15.slice(-20).reduce((a,b)=>a + safeParseFloat(b[5]),0)/Math.min(20, k15.length);
      const volumeSpike = volCurrent > volAvg * 1.3;
      const squeeze = bb ? ((bb.upper - bb.lower) / bb.mean) < 0.045 : false;

      // Score building
      let score = 0;
      if (current > sma200) score += 25;
      if (current > ema50) score += 20;
      if (volumeSpike) score += 20;
      if (squeeze) score += 20;
      if (rsi14 && rsi14 < 60 && rsi14 > 30) score += 10; // healthy mid-rsi
      // ajustar com volume 24h do contexto
      if (context && context.vol_24h && parseFloat(context.vol_24h) > 2_000_000) score += 5;

      // regras negativas
      if (rsi14 && rsi14 > 75) score -= 20; // sobrecompra
      if (!squeeze && !volumeSpike) score -= 10;

      const normalized = Math.max(0, Math.min(100, Math.round(score)));
      const decision = normalized >= config.MIN_CONFIDENCE ? "BUY" : "HOLD";

      // target multiplier: agressivo se squeeze + volumeSpike, conservador se menor confiança
      let targetMultiplier = normalized >= 85 ? 3.2 : normalized >= 70 ? 2.2 : 1.6;
      // eta heurística (minutos) baseado em ATR e squeeze
      const eta_minutes = Math.max(15, Math.round((atr ? (current / atr) : 30) * (squeeze ? 0.7 : 1.2)));

      const reasoning = `Score ${normalized} | SMA200:${sma200.toFixed(4)} EMA50:${ema50.toFixed(4)} RSI:${(rsi14||0).toFixed(2)} ATR:${atr.toFixed(4)} VolSpike:${volumeSpike}`;

      return {
        decision,
        confidence: normalized,
        target_multiplier: targetMultiplier,
        eta_minutes,
        market_bias: normalized >= 60 ? "BULL" : "NEUTRAL",
        reasoning
      };
    }

    /**************************************************************************
     * Opcional: Chamada para LLM remoto (USAR COM CUIDADO). Se config.API_KEY_LLMS
     * estiver vazio o código usa o fallback localOmnisValidate.
     *
     * Esta função tem parsing defensivo e timeout.
     **************************************************************************/
    async function validateWithRemoteAI(symbol, k15, context) {
      if (!config.API_KEY_LLMS) return null;
      const prompt = `Analise para ${symbol}. Forneça APENAS JSON com: {"decision":"BUY"|"HOLD","confidence":0-100,"target_multiplier":number,"eta_minutes":number,"market_bias":"string","reasoning":"string"}. Dados OHLCV: ${JSON.stringify(k15.slice(-30))}. Contexto: ${JSON.stringify(context)}.`;
      const controller = new AbortController();
      const timeout = setTimeout(()=>controller.abort(), 12_000); // 12s timeout
      try {
        // Exemplo: endpoint do Gemini-like (pode não aceitar CORS)
        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${config.API_KEY_LLMS}`;
        const res = await fetch(url, {
          method: "POST",
          headers: { "Content-Type":"application/json" },
          signal: controller.signal,
          body: JSON.stringify({
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: { responseMimeType: "application/json" }
          })
        });
        clearTimeout(timeout);
        if (!res.ok) {
          console.warn('AI remote returned', res.status);
          return null;
        }
        const obj = await res.json();
        const candidate = obj?.candidates?.[0]?.content?.parts?.[0]?.text;
        if (!candidate || typeof candidate !== 'string') return null;
        // Extrair primeiro JSON encontrado (defensivo)
        const firstBrace = candidate.indexOf('{');
        const lastBrace = candidate.lastIndexOf('}');
        if (firstBrace === -1 || lastBrace === -1) return null;
        const rawJson = candidate.slice(firstBrace, lastBrace + 1);
        try {
          const parsed = JSON.parse(rawJson);
          // validar shape
          if (typeof parsed.decision === 'string' && typeof parsed.confidence === 'number') {
            return parsed;
          }
          return null;
        } catch (err) {
          console.warn('JSON parse fail from LLM', err);
          return null;
        }
      } catch (err) {
        console.warn('Remote AI error', err);
        return null;
      } finally {
        clearTimeout(timeout);
      }
    }

    /**************************************************************************
     * Liquidity check via order book (depth). Retorna true se profundidade
     * suficiente para entrada/saída sem slippage extremo.
     **************************************************************************/
    async function checkLiquidity(symbol, minNotionalBRL=10000, usdtBrl=5.0) {
      // usamos Binance order book para obter profundidade (este é front-end => CORS pode aplicar)
      try {
        const depth = await fetch(`https://api.binance.com/api/v3/depth?symbol=${symbol}&limit=50`)
          .then(r => r.ok ? r.json() : null);
        if (!depth) return false;
        // aproximar base de USDT: média de sum das mesmas ordens
        const bidsVol = depth.bids.slice(0,10).reduce((s,b)=>s + safeParseFloat(b[1]) * safeParseFloat(b[0]), 0);
        const asksVol = depth.asks.slice(0,10).reduce((s,a)=>s + safeParseFloat(a[1]) * safeParseFloat(a[0]), 0);
        // notional médio
        const notional = Math.min(bidsVol, asksVol);
        // converter USDT->BRL
        const notionalBRL = notional * usdtBrl;
        return notionalBRL >= minNotionalBRL;
      } catch (e) {
        console.warn('liquidity check fail', e);
        return false;
      }
    }

    /**************************************************************************
     * Backtest simples: percorre candles e aplica regra localOmnisValidate em
     * cada candle (simulação intraday simples). Retorna métricas básicas.
     **************************************************************************/
    function simpleBacktest(k15, lookbackCandles = 500, capitalBRL = config.INITIAL_CAPITAL_BRL) {
      // estratégia: quando localOmnisValidate decide BUY com confidence >= MIN_CONF -> entrar
      const data = k15.slice(-lookbackCandles);
      const closes = data.map(k => safeParseFloat(k[4]));
      const candles = data; // reuse
      let balance = capitalBRL;
      let position = null; // {entryPrice, sizeBRL, stopPrice, targetPrice}
      let trades = [];
      for (let t = 50; t < candles.length; t++) {
        const window15 = candles.slice(0, t+1);
        const window1h = window15; // simplificação: usar mesmo timeframe para teste
        const ctx = { vol_24h: 0 };
        const out = localOmnisValidate('SIM', window15, window1h, ctx);
        const close = safeParseFloat(candles[t][4]);
        if (!position && out.decision === 'BUY' && out.confidence >= config.MIN_CONFIDENCE) {
          const atr = atrFromKlines(window15, 14) || 0.0001;
          const target = close + atr * (out.target_multiplier || 2);
          const stop = close - atr * 1.5;
          // sizing: percent of capital
          const sizeBRL = (config.MAX_CAPITAL_PERCENT_PER_TRADE / 100) * balance;
          position = { entryPrice: close, sizeBRL, stop, target, entryIndex: t };
        }
        if (position) {
          // check hit stop or target at this candle
          const h = safeParseFloat(candles[t][2]);
          const l = safeParseFloat(candles[t][3]);
          let closed = false;
          let exitPrice = close;
          if (l <= position.stop) {
            exitPrice = position.stop;
            closed = true;
          } else if (h >= position.target) {
            exitPrice = position.target;
            closed = true;
          }
          if (closed) {
            const retPct = (exitPrice / position.entryPrice) - 1;
            const profitBRL = position.sizeBRL * retPct - (position.sizeBRL * config.FEE_MB) - (position.sizeBRL * config.SAFETY_BUFFER);
            balance += profitBRL;
            trades.push({ entry: position.entryPrice, exit: exitPrice, retPct, profitBRL, entryIndex: position.entryIndex, exitIndex: t });
            position = null;
          }
        }
      }
      const wins = trades.filter(t => t.profitBRL > 0);
      const loss = trades.filter(t => t.profitBRL <= 0);
      const winrate = trades.length ? (wins.length / trades.length) * 100 : 0;
      const totalPnl = trades.reduce((a,b)=>a + b.profitBRL, 0);
      const avgReturn = trades.length ? (trades.reduce((a,b)=>a + b.retPct,0)/trades.length) : 0;
      return { tradesCount: trades.length, winrate, totalPnl, avgReturn, finalBalance: balance, tradesSample: trades.slice(-10) };
    }

    /**************************************************************************
     * Engine principal: coleta tickers, filtra, analisa e aplica validação
     **************************************************************************/
    const App = () => {
      const [signals, setSignals] = useState([]);
      const [status, setStatus] = useState('IDLE');
      const [usdtBrl, setUsdtBrl] = useState(0);
      const [progress, setProgress] = useState(0);
      const [loading, setLoading] = useState(false);
      const isRunningRef = useRef(false);
      const timerRef = useRef(0);
      const [timerSeconds, setTimerSeconds] = useState(config.SCAN_INTERVAL / 1000);
      const [backtestReport, setBacktestReport] = useState(null);

      const fmtBRL = (v) => {
        try {
          return v.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL', minimumFractionDigits: v < 1 ? 4 : 2 });
        } catch {
          return `R$ ${Number(v).toFixed(2)}`;
        }
      };

      // Core run function: avoids overlap and uses chunking
      const runOmnisEngine = useCallback(async (manual=false) => {
        if (isRunningRef.current) {
          console.log('Engine already running');
          return;
        }
        isRunningRef.current = true;
        setLoading(true);
        setStatus('INICIANDO VARREDURA');
        setProgress(5);
        try {
          // 1) buscar taxa USDTBRL (fallback se não disponível)
          let dollarRate = 1;
          try {
            const uRes = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=USDTBRL')
              .then(r => r.ok ? r.json() : null);
            if (uRes && uRes.price) dollarRate = safeParseFloat(uRes.price);
            else {
              // fallback: usar ticker USDTBUSD ~ 1 (BRL conversion must come from elsewhere)
              dollarRate = usdtBrl || 5.0;
            }
          } catch (e) {
            console.warn('fetch usdtbrl fail', e);
            dollarRate = usdtBrl || 5.0;
          }
          setUsdtBrl(dollarRate);
          setProgress(15);

          // 2) buscar tickers 24h
          const tickers24 = await fetch('https://api.binance.com/api/v3/ticker/24hr')
            .then(r => r.ok ? r.json() : []);
          // filtrar whitelist (comparar com suffix USDT)
          const activeTickers = tickers24.filter(t => {
            try {
              const base = t.symbol.replace('USDT','');
              return config.MB_WHITELIST.includes(base) && safeParseFloat(t.quoteVolume) > config.MIN_QUOTE_VOL;
            } catch { return false; }
          });

          // safety: se nenhum, expandir sem filtro quoteVolume
          const candidates = activeTickers.length ? activeTickers : tickers24.filter(t => config.MB_WHITELIST.includes(t.symbol.replace('USDT',''))).slice(0, 40);

          setProgress(25);
          // chunk and process with defined concurrency
          const groups = chunkArray(candidates, config.POOL_CONCURRENCY);
          const identified = [];

          for (let g = 0; g < groups.length; g++) {
            const group = groups[g];
            // process all in parallel within group
            await Promise.all(group.map(async (ticker, idx) => {
              const symbol = ticker.symbol;
              try {
                // fetch k-lines
                // Obs: reduzir limites para performance, porém manter suficiente para indicadores
                const [k15, k1h] = await Promise.all([
                  fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=15m&limit=200`).then(r => r.ok ? r.json() : null),
                  fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=300`).then(r => r.ok ? r.json() : null)
                ]);
                if (!k15 || !k1h) return;

                const tech = (function performTechnicalScanLocal(k15_, k1h_) {
                  const closes = k15_.map(k => safeParseFloat(k[4]));
                  const current = closes[closes.length - 1];
                  const atr = atrFromKlines(k15_, 14);
                  const sma200 = sma(k1h_.map(k=>safeParseFloat(k[4])), 200) || current;
                  const ema50 = ema(closes, 50) || current;
                  const bb = bollinger(closes, 20, 2);
                  const volCurrent = safeParseFloat(k15_[k15_.length-1][5]);
                  const volAvg = k15_.slice(-20).reduce((a,b)=>a + safeParseFloat(b[5]),0)/Math.min(20, k15_.length);
                  const volumeSpike = volCurrent > volAvg * 1.3;
                  const squeeze = bb ? ((bb.upper - bb.lower) / bb.mean) < 0.04 : false;
                  let score = 0;
                  if (current > sma200) score += 30;
                  if (current > ema50) score += 20;
                  if (volumeSpike) score += 20;
                  if (squeeze) score += 20;
                  return { current, atr, score, isCandidate: score >= 50, sma200, ema50, bb, squeeze, volumeSpike };
                })(k15, k1h);

                // quick skip
                if (!tech.isCandidate) return;

                // check liquidity quick
                const liquidityOk = await checkLiquidity(symbol, 10_000, dollarRate);
                if (!liquidityOk) return;

                // ai validation: try remote then fallback local
                const ctx = { tech_score: tech.score, vol_24h: ticker.quoteVolume, last_price: tech.current };
                let aiVal = null;
                if (config.API_KEY_LLMS) {
                  aiVal = await validateWithRemoteAI(symbol, k15.slice(-40), ctx);
                }
                if (!aiVal) {
                  aiVal = localOmnisValidate(symbol, k15, k1h, ctx);
                }

                if (aiVal && aiVal.decision === 'BUY' && aiVal.confidence >= config.MIN_CONFIDENCE) {
                  const targetMultiplier = aiVal.target_multiplier || 2.2;
                  const targetPrice = tech.current + tech.atr * (targetMultiplier || 2);
                  const grossProfit = (targetPrice / tech.current) - 1;
                  const netProfitPct = (grossProfit - config.FEE_MB - config.SAFETY_BUFFER) * 100;
                  if (netProfitPct > 1.0) {
                    // sizing
                    const suggestedBRL = (config.MAX_CAPITAL_PERCENT_PER_TRADE / 100) * config.INITIAL_CAPITAL_BRL;
                    const stopPrice = tech.current - tech.atr * 1.5;
                    identified.push({
                      coin: symbol.replace('USDT',''),
                      symbol,
                      confidence: aiVal.confidence,
                      priceUSDT: tech.current,
                      priceBRL: tech.current * dollarRate,
                      targetUSDT: targetPrice,
                      targetBRL: targetPrice * dollarRate,
                      stopUSDT: stopPrice,
                      stopBRL: stopPrice * dollarRate,
                      netProfitPct: netProfitPct.toFixed(2),
                      eta: aiVal.eta_minutes + ' min',
                      bias: aiVal.market_bias,
                      insight: aiVal.reasoning,
                      suggestedBRL
                    });
                  }
                }
              } catch (err) {
                // silencioso para não travar grupo
                console.warn('tick error', ticker?.symbol, err);
              }
            }));
            setProgress(Math.round(25 + (g / groups.length) * 60));
          } // end groups

          // ordenar por confidence e netProfit
          identified.sort((a,b) => b.confidence - a.confidence || parseFloat(b.netProfitPct) - parseFloat(a.netProfitPct));
          setSignals(identified);
          setStatus('IDLE');
          setProgress(100);
          setLoading(false);
        } catch (err) {
          console.error('Engine error', err);
          setStatus('ERRO NO NÓ DE DADOS');
          setLoading(false);
        } finally {
          isRunningRef.current = false;
        }
      }, [usdtBrl]);

      // timer e auto-scan
      useEffect(() => {
        runOmnisEngine();
        let countdown = config.SCAN_INTERVAL / 1000;
        setTimerSeconds(countdown);
        const tick = setInterval(() => {
          countdown -= 1;
          if (countdown <= 0) {
            runOmnisEngine();
            countdown = config.SCAN_INTERVAL / 1000;
          }
          setTimerSeconds(countdown);
        }, 1000);
        return () => clearInterval(tick);
      }, [runOmnisEngine]);

      // UI handlers
      const handleManualRun = () => runOmnisEngine(true);

      const handleBacktest = async (symbol) => {
        try {
          setBacktestReport({ running: true });
          // obter candles
          const k15 = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=15m&limit=1000`).then(r => r.ok ? r.json() : []);
          if (!k15 || k15.length === 0) {
            setBacktestReport({ error: 'falha ao obter candles' });
            return;
          }
          const report = simpleBacktest(k15, 800, config.INITIAL_CAPITAL_BRL);
          setBacktestReport(report);
        } catch (e) {
          setBacktestReport({ error: e.message });
        }
      };

      return (
        <div className="max-w-7xl mx-auto p-4 lg:p-12 relative min-h-screen">
          <div className="fixed top-0 left-0 w-full z-50 h-1 bg-white/5"><div className="progress-bar h-full" style={{width: `${progress}%`}}></div></div>

          <div className="glass glow-indigo rounded-[40px] p-8 mb-12 relative overflow-hidden">
            <div className="scan-bar opacity-20"></div>
            <div className="flex flex-col lg:flex-row justify-between items-center gap-8 relative z-20">
              <div className="flex items-center gap-6">
                <div className="p-4 bg-indigo-600/20 rounded-2xl border border-indigo-500/30">
                  <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="#6366f1" strokeWidth="2.5"><circle cx="12" cy="12" r="10"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/><path d="M2 12h20"/></svg>
                </div>
                <div>
                  <h1 className="text-3xl font-black h-gradient tracking-tighter uppercase leading-none">Omnis-Vision <span className="text-white opacity-40 text-lg font-light tracking-normal">Elite Engine — Frontend</span></h1>
                  <p className="text-[10px] mono text-slate-500 uppercase tracking-[0.3em] flex items-center gap-2 mt-2">
                    <span className="w-2 h-2 bg-indigo-500 rounded-full animate-pulse"></span>
                    {status} | USDT↔BRL: {usdtBrl ? usdtBrl.toFixed(2) : '—'}
                  </p>
                </div>
              </div>

              <div className="flex items-center gap-6">
                <div className="text-right mr-4">
                  <p className="text-[9px] font-bold text-slate-600 uppercase tracking-widest mb-1 italic">Próxima varredura</p>
                  <p className="text-3xl font-black text-white mono leading-none">{timerSeconds}s</p>
                </div>
                <div className="flex gap-3">
                  <button onClick={handleManualRun} className="btn p-4 bg-white/5 hover:bg-white/10 rounded-2xl border border-white/10 transition-all active:scale-95 shadow-xl">Rodar Agora</button>
                  <button onClick={() => { setSignals([]); setBacktestReport(null); }} className="btn p-4 bg-red-700/10 hover:bg-red-700/20 rounded-2xl border border-red-700/10 transition-all">Limpar</button>
                </div>
              </div>
            </div>
          </div>

          <div className="grid grid-cols-1 lg:grid-cols-12 gap-10">
            <div className="lg:col-span-8 space-y-8">
              {loading ? (
                <div className="glass p-20 rounded-[50px] text-center border-indigo-500/10 relative overflow-hidden">
                  <div className="scan-bar opacity-10"></div>
                  <div className="w-16 h-16 border-4 border-indigo-500 border-t-transparent rounded-full animate-spin mx-auto mb-6"></div>
                  <p className="text-[10px] font-black text-slate-500 tracking-[0.6em] uppercase animate-pulse">Varredura em execução...</p>
                </div>
              ) : signals.length === 0 ? (
                <div className="glass p-12 rounded-[50px] text-center border-dashed border-white/10 opacity-60">
                  <p className="text-slate-400 italic">Nenhuma confluência de alta probabilidade detectada no momento.</p>
                </div>
              ) : (
                signals.map((s, i) => (
                  <div key={i} className="glass tech-card rounded-[30px] p-6 relative overflow-hidden group shadow-2xl">
                    <div className="absolute top-0 right-0 p-6 text-right z-10">
                      <div className="text-[9px] font-black text-slate-600 uppercase mb-1 tracking-tighter">Omnis Confidence</div>
                      <div className="text-4xl font-black text-indigo-400 opacity-80 italic">{s.confidence}%</div>
                    </div>

                    <div className="flex items-center gap-6 mb-4 relative z-10">
                      <div className="w-16 h-16 bg-gradient-to-br from-indigo-600 to-indigo-950 rounded-xl flex items-center justify-center text-2xl font-black text-white shadow-2xl border border-white/10 italic">
                        {s.coin[0]}
                      </div>
                      <div>
                        <h3 className="text-2xl font-black text-white tracking-tight uppercase italic">{s.coin}</h3>
                        <div className="flex gap-3 mt-3">
                          <div className="bg-emerald-500/8 border border-emerald-500/20 px-3 py-1 rounded-2xl">
                            <span className="text-xs font-black text-emerald-300 uppercase tracking-widest">LUCRO: +{s.netProfitPct}%</span>
                          </div>
                          <div className="bg-indigo-500/8 border border-indigo-500/20 px-3 py-1 rounded-2xl">
                            <span className="text-xs font-black text-indigo-300 uppercase tracking-widest">EST: {s.eta}</span>
                          </div>
                          <div className="bg-white/5 border border-white/10 px-3 py-1 rounded-2xl">
                            <span className="text-xs font-black text-slate-400 uppercase tracking-widest">VIÉS: {s.bias}</span>
                          </div>
                        </div>
                      </div>
                    </div>

                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                      <div className="p-4 rounded-lg border bg-white/[0.02]">
                        <p className="text-[10px] text-slate-500 uppercase">Entrada (BRL)</p>
                        <div className="text-xl mono font-black">{fmtBRL(s.priceBRL)}</div>
                      </div>
                      <div className="p-4 rounded-lg border bg-white/[0.02]">
                        <p className="text-[10px] text-slate-500 uppercase">Alvo (BRL)</p>
                        <div className="text-xl mono font-black">{fmtBRL(s.targetBRL)}</div>
                      </div>
                      <div className="p-4 rounded-lg border bg-white/[0.02]">
                        <p className="text-[10px] text-slate-500 uppercase">Stop (BRL)</p>
                        <div className="text-xl mono font-black">{fmtBRL(s.stopBRL)}</div>
                      </div>
                    </div>

                    <div className="flex items-center justify-between gap-4 pt-4 border-t border-white/5">
                      <p className="text-xs text-slate-400 italic">"{s.insight}"</p>
                      <div className="flex gap-3">
                        <a href={`https://www.mercadobitcoin.com.br/negociacoes/${s.coin.toLowerCase()}`} target="_blank" rel="noopener noreferrer" className="px-4 py-2 bg-white text-black rounded-xl uppercase text-xs font-black">Executar no MB</a>
                        <button onClick={() => handleBacktest(s.symbol)} className="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded-xl uppercase text-xs font-black">Backtest</button>
                      </div>
                    </div>
                  </div>
                ))
              )}
            </div>

            <div className="lg:col-span-4 space-y-8">
              <div className="glass p-6 rounded-[20px] border-indigo-500/20 shadow-2xl">
                <h3 className="text-xs font-black text-white mb-4 uppercase italic tracking-widest flex items-center gap-3"><div className="w-2.5 h-2.5 bg-indigo-400 rounded-full shadow-[0_0_15px_#6366f1]"></div>Omnis Protocol vFull</h3>
                <p className="text-[12px] text-slate-300 italic mb-4">Frontend-only mode. Sistema projetado para maximizar probabilidade com regras institucionais, validação por heurística e verificação de liquidez. Para implantação real (ordens automáticas, chaves privadas), use backend seguro.</p>

                <div className="text-sm space-y-3">
                  <div><strong>Filtro liquidez:</strong> {config.MIN_QUOTE_VOL.toLocaleString('pt-BR')}</div>
                  <div><strong>Capital inicial (simulação):</strong> {fmtBRL(config.INITIAL_CAPITAL_BRL)}</div>
                  <div><strong>Max por trade:</strong> {config.MAX_CAPITAL_PERCENT_PER_TRADE}%</div>
                </div>
              </div>

              <div className="bg-gradient-to-br from-indigo-950/30 to-black p-6 rounded-[20px] border border-indigo-500/20 shadow-2xl">
                <h4 className="text-xs font-black text-slate-400 uppercase tracking-[0.3em] mb-3 italic">Backtest</h4>
                {backtestReport ? (
                  backtestReport.error ? (
                    <p className="text-sm text-red-400">{backtestReport.error}</p>
                  ) : backtestReport.running ? (
                    <p className="text-sm text-slate-400">Executando...</p>
                  ) : (
                    <div className="text-sm text-slate-300 space-y-2">
                      <div>Trades: {backtestReport.tradesCount}</div>
                      <div>Winrate: {backtestReport.winrate.toFixed(2)}%</div>
                      <div>Total PnL: {fmtBRL(backtestReport.totalPnl)}</div>
                      <div>Final Balance: {fmtBRL(backtestReport.finalBalance)}</div>
                    </div>
                  )
                ) : (
                  <p className="text-sm text-slate-400">Clique em "Backtest" em qualquer sinal para rodar uma simulação rápida.</p>
                )}
              </div>

              <div className="glass p-6 rounded-[20px]">
                <h4 className="text-xs font-black text-white uppercase italic mb-2">Atenção</h4>
                <ul className="text-xs text-slate-400 list-disc ml-4 space-y-2">
                  <li>Este projeto é front-end apenas — chaves expostas significam risco.</li>
                  <li>Integração de ordens reais requer backend seguro, KYC e medidas anti-fraud.</li>
                  <li>Resultados simulados não garantem performance futura. Teste em conta demo.</li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      );
    };

    // render
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
